{"ast":null,"code":"import colors from './colors.js';\nimport algorithms from './algorithms.js';\nconst utils = {\n  randomize: (size, unique) => {\n    let data = [];\n\n    if (unique) {\n      for (let i = 1; i <= size; i++) {\n        data.push({\n          x: i,\n          y: i,\n          color: colors.default\n        });\n      }\n\n      ;\n    } else {\n      for (let i = 1; i <= size; i++) {\n        data.push({\n          x: i,\n          y: Math.floor(Math.random() * size + 1),\n          color: colors.default\n        });\n      }\n\n      ;\n    }\n\n    for (let i = data.length - 1; i >= 0; i--) {\n      let rand = Math.floor(Math.random() * (i + 1));\n      let temp = data[rand].y;\n      data[rand].y = data[i].y;\n      data[i].y = temp;\n    }\n\n    return data;\n  },\n  swap: (values, i, j) => {\n    let temp = values[i];\n    values[i] = values[j];\n    values[j] = temp;\n    return values;\n  },\n  getSolutionSteps: (data, algo) => {\n    let values = data.map(item => item.y);\n    let steps = [];\n\n    switch (algo) {\n      case 'insertion':\n        steps = algorithms.insertion(values);\n        break;\n\n      case 'selection':\n        steps = algorithms.selection(values);\n        break;\n\n      default:\n        break;\n    }\n\n    steps.push({\n      colors: [],\n      changedValues: []\n    });\n    return steps;\n  },\n  performStep: (data, step) => {\n    if (step.type === 'color') {\n      for (let i = 0; i < data.length; i++) {\n        data[i].color = colors.default;\n\n        if (i >= step.sorted.begin && i <= step.sorted.end) {\n          data[i].color = colors.sorted;\n        }\n      }\n\n      for (let i = 0; i < step.colors.length; i++) {\n        let ind = step.colors[i].ind;\n        data[ind].color = step.colors[i].color;\n      }\n    } else if (step.type === 'swap') {\n      let ind0 = step.swap.ind0;\n      data[ind0].y = step.swap.val0;\n      let ind1 = step.swap.ind1;\n      data[ind1].y = step.swap.val1;\n    }\n\n    return data;\n  },\n  performInverseStep: (data, steps, stepInd) => {\n    if (steps[stepInd].changedValues.length !== 0) {\n      for (let i = 0; i < data.length; i++) {\n        data[i].color = colors.default;\n      }\n\n      for (let i = 0; i < steps[stepInd].colors.length; i++) {\n        let ind = steps[stepInd].colors[i].ind;\n        data[ind].color = steps[stepInd].colors[i].color;\n      }\n\n      if (steps[stepInd].changedValues.length === 2) {\n        let ind0 = steps[stepInd].changedValues[0].ind;\n        data[ind0].y = steps[stepInd].changedValues[1].value;\n        let ind1 = steps[stepInd].changedValues[1].ind;\n        data[ind1].y = steps[stepInd].changedValues[0].value;\n      }\n    } else {\n      data = utils.performStep(data, steps[stepInd - 1]);\n    }\n\n    return data;\n  }\n};\nexport default utils;","map":{"version":3,"sources":["/home/asalmi/Documents/sort2.0/src/utils.js"],"names":["colors","algorithms","utils","randomize","size","unique","data","i","push","x","y","color","default","Math","floor","random","length","rand","temp","swap","values","j","getSolutionSteps","algo","map","item","steps","insertion","selection","changedValues","performStep","step","type","sorted","begin","end","ind","ind0","val0","ind1","val1","performInverseStep","stepInd","value"],"mappings":"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","sourcesContent":["import colors from './colors.js';\nimport algorithms from './algorithms.js'\n\nconst utils = {\n    randomize: (size, unique) => {\n        let data = [];\n        if(unique){\n            for(let i=1; i<=size; i++){\n                data.push({x: i, y: i, color: colors.default})\n            };\n        }\n        else{\n            for(let i=1; i<=size; i++){\n                data.push({x: i, y:  Math.floor(Math.random() * size + 1), color: colors.default})\n            };\n        }\n        \n        for(let i=data.length-1; i>=0; i--){\n            let rand = Math.floor(Math.random() * (i + 1));\n            let temp = data[rand].y;\n            data[rand].y = data[i].y;\n            data[i].y = temp;\n        }\n\n        return data;\n    },\n\n    swap: (values, i, j) => {\n        let temp = values[i];\n        values[i] = values[j];\n        values[j] = temp;\n\n        return values;\n    },\n\n    getSolutionSteps: (data, algo) => {\n        let values = data.map(item => item.y);\n        let steps = [];\n\n        switch (algo) {\n            case 'insertion':\n                steps = algorithms.insertion(values);\n                break;\n            case 'selection':\n                steps = algorithms.selection(values);\n                break;\n            default:\n                break;\n\n        }\n\n        steps.push({\n            colors: [],\n            changedValues: []\n        });\n    \n        return steps;\n    },\n\n    performStep: (data, step) => {\n        if(step.type === 'color'){\n            for(let i=0; i<data.length; i++){\n                data[i].color = colors.default;\n\n                if(i >= step.sorted.begin && i <= step.sorted.end){\n                    data[i].color = colors.sorted;\n                }\n            }\n    \n            for(let i=0; i<step.colors.length; i++){\n                let ind = step.colors[i].ind;\n                data[ind].color = step.colors[i].color;\n            }\n        }\n        else if(step.type === 'swap'){\n            let ind0 = step.swap.ind0;\n            data[ind0].y = step.swap.val0\n            let ind1 = step.swap.ind1;\n            data[ind1].y = step.swap.val1;\n        }\n\n        return data;\n    },\n\n    performInverseStep: (data, steps, stepInd) => {\n        if(steps[stepInd].changedValues.length !== 0){\n            for(let i=0; i<data.length; i++){\n                data[i].color = colors.default;\n            }\n    \n            for(let i=0; i<steps[stepInd].colors.length; i++){\n                let ind = steps[stepInd].colors[i].ind;\n                data[ind].color = steps[stepInd].colors[i].color\n            }\n\n            if(steps[stepInd].changedValues.length === 2){\n                let ind0 = steps[stepInd].changedValues[0].ind;\n                data[ind0].y = steps[stepInd].changedValues[1].value;\n\n                let ind1 = steps[stepInd].changedValues[1].ind;\n                data[ind1].y = steps[stepInd].changedValues[0].value;\n            }\n        }\n        else{\n          data = utils.performStep(data, steps[stepInd-1]);\n        }\n\n        return data;\n    }\n}\n\nexport default utils;"]},"metadata":{},"sourceType":"module"}